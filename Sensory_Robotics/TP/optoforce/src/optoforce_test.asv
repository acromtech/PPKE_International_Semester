% This is a simple script demonstrating the usage of Optoforce sensors' 
% output from MATLAB.
% Before starting: 
% Windows: please check under Control Panel / System / Device Manager
% that under which serial-port your optoforce device is connected
% Linux: sudo ln -s /dev/ttyACM0 /devttyS100
% 
% After you have opened the serial-object attached to the optoforce sensor,
% it will continuously send you its 14-bytes long packages, according to 
% the following scheme:
% 55 67 [config] [s1H] [s1L] [s2H] [s2L] [s3H] [s3L] [s4H] [s4L] [tempH] [tempL] [checksum]
% computing checksum: config+s1+s2+s3+s4+temp but all of these summations on 8 bit only.
% computing coordinates:
% x = s1 - s3
% y = s2 - s4
% z = (s1 + s2 + s3 + s4) / 4
% 
    
    close all;
    clear;
    clc;
    
    
    format long;
   
    optoforce = serial('/dev/ttyACM0', 'baudrate', 115200);
    set(optoforce, 'InputBufferSize', 1000);
    buffer = [];
    
    figure(1);
    force_direction = line([0 0], [0 0], [0 0], 'Color', 'r', 'LineWidth', 3);
    xlim([-20 20]);
    ylim([-20 20]);
    zlim([0 20]);
    xlabel('X');
    ylabel('Y');
    zlabel('Z');
    view(15, 35);
    grid on;
    
    fopen(optoforce);
    [data, pieces] = fread(optoforce, 100);
    buffer = data;
    ind_start = find(buffer==55, 1);
    while (buffer(ind_start+1) ~= 67)
        ind_start2 = find(buffer(ind_start+1:end)==55, 1);
        ind_start = ind_start+ind_start2;
    end
    if (ind_start>1)
        buffer(1:ind_start-1) = [];
        ind_start = 1;
    end
    % to set up the offsets:
    s1 = buffer(ind_start+3)*256 + buffer(ind_start+4);
    s2 = buffer(ind_start+5)*256 + buffer(ind_start+6);
    s3 = buffer(ind_start+7)*256 + buffer(ind_start+8);
    s4 = buffer(ind_start+9)*256 + buffer(ind_start+10);
    x_orig = s3-s1;
    y_orig = s2-s4;
    z_orig = s1+s2+s3+s4;
    
    index=0;
    end_idx = 100;
    res_t = zeros(1, 7*end_idx);
    x_t = zeros(1, 7*end_idx);
    y_t = zeros(1, 7*end_idx);
    z_t = zeros(1, 7*end_idx);
    res_idx = 1;
    
    for ind=1:end_idx
        while (ind_start+13<=length(buffer))
            
            %index=index+1;
            s1 = buffer(ind_start+3)*256 + buffer(ind_start+4);
            s2 = buffer(ind_start+5)*256 + buffer(ind_start+6);
            s3 = buffer(ind_start+7)*256 + buffer(ind_start+8);
            s4 = buffer(ind_start+9)*256 + buffer(ind_start+10);
            xc = (s3-s1-x_orig)/60; %in theory the denom. should be 100, and the nomin. s1-s3 ...
            yc = (s2-s4-y_orig)/60; %same
            zc = (s1+s2+s3+s4-z_orig)/400;
            res_t(res_idx) = sqrt(xc^2+yc^2+zc^2);
            x_t(res_idx) = xc;
            y_t(res_idx) = yc;
            z_t(res_idx) = zc;
            res_idx = res_idx+1;
            
            set(force_direction, 'XData', [0 xc], 'YData', [0 yc], 'ZData', [0 zc]);
            drawnow;
            pause(0.01);
            ind_start = ind_start+14;
        end
        %[data, pieces] = fread(optoforce, 100); % this read is just to empty the receiver buffer
        [data, pieces] = fread(optoforce, 100);
        buffer = data;
        ind_start = find(buffer==55, 1);
        while (buffer(ind_start+1) ~= 67)
            ind_start2 = find(buffer(ind_start+1:end)==55, 1);
            ind_start = ind_start+ind_start2;
        end
        if (ind_start>1)
            buffer(1:ind_start-1) = [];
            ind_start = 1;
        end
    end
   
    
    fclose(optoforce);
    
    figure(2);
    plot(res_t, 'b*-');
    save(strcat('./optoforce_raw_coords_2', num2str(now, 16), '.mat'), 'x_t', 'y_t', 'z_t','res_t');
    
